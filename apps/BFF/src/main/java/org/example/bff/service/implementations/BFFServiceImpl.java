package org.example.bff.service.implementations;

import graphql.ParseAndValidate;
import graphql.language.Document;
import graphql.parser.Parser;
import graphql.schema.GraphQLSchema;
import graphql.schema.idl.SchemaParser;
import graphql.schema.idl.TypeDefinitionRegistry;
import graphql.schema.idl.UnExecutableSchemaGenerator;
import graphql.validation.ValidationError;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.example.bff.domain.llm.LLMResponse;
import org.example.bff.domain.request.RequestModel;
import org.example.bff.metrics.BFFMetrics;
import org.example.bff.service.BFFService;
import org.example.bff.infrastructure.LLMService;
import org.example.bff.infrastructure.BackendGraphQLService;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@Slf4j
@AllArgsConstructor
public class BFFServiceImpl implements BFFService {
    private LLMService llmService;
    private BackendGraphQLService backendGraphQLService;
    private BFFMetrics bffMetrics;


    @Override
    public ResponseEntity<?> processRequest(final RequestModel request, final String language) {
        log.info("Processing request: {}", request);
        final String graphQlSchema = backendGraphQLService.fetchGraphQLSchema();
        final LLMResponse llmResponse = llmService.generateGraphQLQuery(graphQlSchema, request.getTextPrompt(), language, request.getContext(), request.getLlmModel(), request.isShouldCallRealLLM(), request.isReturnLLMResponse());
        if (request.isReturnLLMResponse()) {
            return ResponseEntity.ok(llmResponse.getMessage());
        }
        return switch (llmResponse.getStatus()) {
            case OK -> {
                final boolean isQueryValid = isQueryOrMutationValid(graphQlSchema, llmResponse.getMessage());
                if (!isQueryValid) {
                    yield ResponseEntity.internalServerError().body("Invalid query or mutation generated by LLM");
                }
                final Object backendResponse = backendGraphQLService.queryGraphQLServer(llmResponse.getMessage());
                yield backendResponse != null
                        ? ResponseEntity.ok(backendResponse)
                        : ResponseEntity.noContent().build();
            }
            case ERROR -> ResponseEntity.badRequest().body(llmResponse.getMessage());
            case INFO -> ResponseEntity.ok(llmResponse.getMessage());
            default -> ResponseEntity.internalServerError().body("Unexpected response from LLM");
        };
    }

    private boolean isQueryOrMutationValid(final String graphQlSchema, final String query) {
        final TypeDefinitionRegistry registry = new SchemaParser().parse(graphQlSchema);
        final GraphQLSchema schema = UnExecutableSchemaGenerator.makeUnExecutableSchema(registry);

        final Document inputDocument = new Parser().parseDocument(query);
        final List<ValidationError> errors = ParseAndValidate.validate(schema, inputDocument);

        final boolean isValid = errors.isEmpty();
        if (!isValid) {
            log.warn("Invalid query or mutation: {}. Errors: {}", query, errors);
        }

        bffMetrics.trackQueriesOrMutationsValidCount(isValid);
        return isValid;
    }
}
